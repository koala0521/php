# PHP正则

标签（空格分隔）： PHP正则 

---


### php正则表达示的定界符

PHP的正则表达示定界符的规定如下：

定界符，不能用a-z A-Z 0-9 \ 其他的都可以用。必须成对出现，有开始就有结束。

我们来例几个例子：

- /中间写正则/	正确
- %中间写正则%	正确
- ^中间写正则^	正确
- @中间写正则@	正确
- (中间写正则)	错误
- A中间写正则A	错误

**原子**
原子是正则表达示里面的最小单位，原子说白了就是需要匹配的内容。一个成立的正则表达示当中必须最少要有一个原子。
说明：我们见到的空格、回车、换行、0-9、A-Za-z、中文、标点符号、特殊符号全为原子。

preg_match 函数

int preg_match ( string \$正则 , string \$字符串 [, array &\$结果] )

功能：根据\$正则变量，匹配\$字符串变量。如果**存在则返回匹配的个数**，把匹配到的结果放到\$结果变量里。**如果没有匹配到结果返回0**。
**结果变量**的值是一个数组，没有匹配到则是一个空数组。
```
<?php
//定义一个变量叫zz，放正则表达示。为了方便大家记忆，如果你英文比较ok，建议把变量名还是写成英文的$pattern
$zz = '/a/';

$string = 'ddfdjjvi2jfvkwkfi24';

if(preg_match($zz, $string, $matches)){
   echo '匹配到了，结果为：';
   var_dump($matches);
}else{
   echo '没有匹配到';
}

?>
```

特殊标识的原子

|原子	|说明
|--|--|
|\d	|匹配一个0-9
|\D	|除了0-9以外的所有字符
|\w	|a-zA-Z0-9_
|\W	|除了0-9A-Za-z_以外的所有字符
|\s	|匹配所有空白字符\n \t \r 空格
|\S	|匹配所有非空白字符
|[ ]	|指定范围的原子

我们看看 [] 指定范围的原子

```
<?php

$zz = '/[0-5]\w+/'; //匹配0-5的任意一个数字和最少一个字符

$string = '6a';

$string1 = '1C';

if(preg_match($zz, $string, $matches)){
   echo '匹配到了，结果为：';
   var_dump($matches);
}else{
   echo '没有匹配到';
}

// $string 匹配失败

// $string1匹配成功

?>
```

**[^ 字符] 不匹配指定区间的字符**

```
<?php

$zz = '/[^\w]/';    //匹配一个非字符

$string = 'aaaaab311dd';

$string1 = '!$@!#%$#^##';

if(preg_match($zz, $string1, $matches)){
   echo '匹配到了，结果为：';
   var_dump($matches);
}else{
   echo '没有匹配到';
}


// $string 匹配失败

// $string1匹配成功

?>
```

|原子	|等价式
|--|--|
|\w	|[a-zA-Z0-9_]
|\W	|[^a-zA-Z0-9_]
|\d	|[0-9]
|\D	|[^0-9]
|\s	|[ \t\n\f\r]
|\S	|[^ \t\n\f\r]

#### php正则表示中的元字符

抛出问题： \d 代表匹配一个字符。而我现在想要匹配十个八个，任意多个数字肿么办？

这个时候我们就要用到元字符。在使用原子的时候，发现只能够匹配一个字符，可是要匹配多个字符就出现了问题。
这个时候，我们需要借助元字符来帮我们修饰原子，实现更多的功能。

|元字符	|功能说明
|--|--|
|*	|是代表匹配前面的一个原子，匹配0次或者任意多次前面的字符。
|+	|匹配一次或多前前面的一个字符
|?	|前面的字符可有可无【可选】 有或没有
|.	|更标准一些应该把点算作原子。匹配除了\n以外的所有字符
|\|   |或者。注：它的优先级最低了。
|^	|必须要以抑扬符之后的字符串开始
|\$	|必须要以\$之前的字符结尾
|\b	|词边界
|\B	|非边界
|{m}	|有且只能出现m次
| {n,m}	|可以出现n到m次
|{m,}	|至少m次，最大次数不限制
|()	|改变优先级或者将某个字符串视为一个整体，匹配到的数据取出来也可以使用它

#### php 正则达达示中的模式修正符

如果abc在第二行的开始处如何匹配？
我不希望正则表达示特别贪婪的匹配全部，只匹配一部份怎么办？

常用的模式匹配符有：

|模式匹配符	|功能
|--|--||
|i	|模式中的字符将同时匹配大小写字母.
|m	|字符串视为多行
|s	|将字符串视为单行,换行符作为普通字符.
|x	|将模式中的空白忽略.
|A	|强制仅从目标字符串的开头开始匹配.
|D	|模式中的美元元字符仅匹配目标字符串的结尾.
|U	|匹配最近的字符串.

m 视为多行
```
<?php
$pattern = '/^a\d+/m';  //多行匹配开头a和一个数字
$string = "我的未来在自己手中我需要不断的努力
a9是一个不错的字符表示
怎么办呢，其实需要不断奋进";
if (preg_match($pattern, $string, $matches)) {
    echo '匹配到了，结果为：';
    var_dump($matches);
} else {
    echo '没有匹配到';
}

// 匹配成功 'a9'
?>
```
**s 识为一行**

```
<?php

$pattern = '/新的未来.+\d+/';

$string = '新的未来
987654321';

if (preg_match($pattern, $string, $matches)) {
   echo '匹配到了，结果为：';
   var_dump($matches);
} else {
   echo '没有匹配到';
}
//没有匹配到

//-----------------------------------------------------//
$pattern = '/新的未来.+\d+/s';   //后面加了s

$string = "新的未来
987654321";

if (preg_match($pattern, $string, $matches)) {
   echo '匹配到了，结果为：';
   var_dump($matches);
} else {
   echo '没有匹配到';
}

// 匹配成功 ：   "新的未来 987654321"
?>


```
### 常用正则函数
|函数名	|功能
|--|--|
|preg_filter	|执行一个正则表达式搜索和替换
|preg_grep	|返回匹配模式的数组条目
|preg_match	|执行一个正则表达式匹配
|preg_match_all	|执行一个全局正则表达式匹配
|preg_replace_callback_array	|传入数组，执行一个正则表达式搜索和替换使用回调
|preg_replace_callback	|执行一个正则表达式搜索并且使用一个回调进行替换
|preg_replace	|执行一个正则表达式的搜索和替换
|preg_split	|通过一个正则表达式分隔字符串




